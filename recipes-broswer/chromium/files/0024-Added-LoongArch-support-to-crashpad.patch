From 8328aa5e80d10264518df8a23e1fa11759311ca3 Mon Sep 17 00:00:00 2001
From: qing zhang <zhangqing199801@gmail.com>
Date: Mon, 21 Nov 2022 18:19:47 +0800
Subject: [PATCH] Added LoongArch support to crashpad

Signed-off-by: qing zhang <zhangqing199801@gmail.com>
Change-Id: I210537119edbff4d1174da1ca50b2a4259460af1
---

diff --git a/compat/linux/sys/ptrace.h b/compat/linux/sys/ptrace.h
index 604a46a..0f13e12 100644
--- a/compat/linux/sys/ptrace.h
+++ b/compat/linux/sys/ptrace.h
@@ -38,6 +38,10 @@
 static constexpr __ptrace_request PTRACE_GET_THREAD_AREA_3264 =
     static_cast<__ptrace_request>(0xc4);
 #define PTRACE_GET_THREAD_AREA_3264 PTRACE_GET_THREAD_AREA_3264
+#elif defined(__loongarch64)
+static constexpr __ptrace_request PTRACE_GET_THREAD_AREA =
+    static_cast<__ptrace_request>(25);
+#define PTRACE_GET_THREAD_AREA PTRACE_GET_THREAD_AREA
 #endif
 #endif  // !PTRACE_GET_THREAD_AREA && !PT_GET_THREAD_AREA && defined(__GLIBC__)
 
diff --git a/compat/non_win/winnt.h b/compat/non_win/winnt.h
index 5fd78b0..57a9720 100644
--- a/compat/non_win/winnt.h
+++ b/compat/non_win/winnt.h
@@ -67,6 +67,7 @@
 #define PROCESSOR_ARCHITECTURE_NEUTRAL 11
 #define PROCESSOR_ARCHITECTURE_ARM64 12
 #define PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64 13
+#define PROCESSOR_ARCHITECTURE_LOONGARCH64 14
 #define PROCESSOR_ARCHITECTURE_UNKNOWN 0xffff
 //! \}
 
diff --git a/minidump/minidump_context.h b/minidump/minidump_context.h
index 30988d8..586c27a 100644
--- a/minidump/minidump_context.h
+++ b/minidump/minidump_context.h
@@ -637,6 +637,36 @@
   uint64_t fir;
 };
 
+//! \brief LOONGARCH64-specifc flags for MinidumpContextLOONGARCH64::context_flags.
+//! Based on minidump_cpu_loongarch64.h from breakpad
+enum MinidumpContextLOONGARCH64Flags : uint32_t {
+  //! \brief Identifies the context structure as LOONGARCH64.
+  kMinidumpContextLOONGARCH64 = 0x00800000,
+
+  //! \brief Indicates the validity of integer registers.
+  //!
+  //! Registers `0`-`31`, `epc` are valid.
+  kMinidumpContextLOONGARCH64Integer = kMinidumpContextLOONGARCH64 | 0x00000002,
+
+  //! \brief Indicates the validity of floating point registers.
+  //!
+  //! Floating point registers `0`-`31`, `fpcsr` and `fir` are valid
+  kMinidumpContextLOONGARCH64FloatingPoint = kMinidumpContextLOONGARCH64 | 0x00000004,
+
+  //! \brief Indicates the validity of all registers.
+  kMinidumpContextLOONGARCH64All = kMinidumpContextLOONGARCH64Integer |
+                              kMinidumpContextLOONGARCH64FloatingPoint,
+};
+
+//! \brief A LOONGARCH64 CPU context (register state) carried in a minidump file.
+struct MinidumpContextLOONGARCH64 {
+  uint32_t context_flags;
+  uint64_t sc_pc;
+  uint64_t sc_regs[32];
+  uint64_t fregs[32];
+  uint64_t fcc;
+  uint32_t fcsr;
+};
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_H_
diff --git a/minidump/minidump_context_writer.cc b/minidump/minidump_context_writer.cc
index 5f741ed..ce801ec 100644
--- a/minidump/minidump_context_writer.cc
+++ b/minidump/minidump_context_writer.cc
@@ -102,6 +102,13 @@
       break;
     }
 
+    case kCPUArchitectureLOONGARCH64: {
+      context = std::make_unique<MinidumpContextLOONGARCH64Writer>();
+      reinterpret_cast<MinidumpContextLOONGARCH64Writer*>(context.get())
+          ->InitializeFromSnapshot(context_snapshot->loongarch64);
+      break;
+    }
+
     default: {
       LOG(ERROR) << "unknown context architecture "
                  << context_snapshot->architecture;
@@ -556,4 +563,41 @@
   return sizeof(context_);
 }
 
+MinidumpContextLOONGARCH64Writer::MinidumpContextLOONGARCH64Writer()
+    : MinidumpContextWriter(), context_() {
+  context_.context_flags = kMinidumpContextLOONGARCH64;
+}
+
+MinidumpContextLOONGARCH64Writer::~MinidumpContextLOONGARCH64Writer() = default;
+
+void MinidumpContextLOONGARCH64Writer::InitializeFromSnapshot(
+    const CPUContextLOONGARCH64* context_snapshot) {
+  DCHECK_EQ(state(), kStateMutable);
+  DCHECK_EQ(context_.context_flags, kMinidumpContextLOONGARCH64);
+
+  context_.context_flags = kMinidumpContextLOONGARCH64All;
+
+  static_assert(sizeof(context_.sc_regs) == sizeof(context_snapshot->sc_regs),
+                "GPRs size mismatch");
+  memcpy(context_.sc_regs, context_snapshot->sc_regs, sizeof(context_.sc_regs));
+  context_.sc_pc = context_snapshot->sc_pc;
+
+  static_assert(sizeof(context_.fregs) == sizeof(context_snapshot->fregs),
+                "FPU size mismatch");
+  memcpy(context_.fregs, context_snapshot->fregs, sizeof(context_.fregs));
+  context_.fcsr = context_snapshot->fcsr;
+  context_.fcc = context_snapshot->fcc;
+}
+
+bool MinidumpContextLOONGARCH64Writer::WriteObject(
+    FileWriterInterface* file_writer) {
+  DCHECK_EQ(state(), kStateWritable);
+  return file_writer->Write(&context_, sizeof(context_));
+}
+
+size_t MinidumpContextLOONGARCH64Writer::ContextSize() const {
+  DCHECK_GE(state(), kStateFrozen);
+  return sizeof(context_);
+}
+
 }  // namespace crashpad
diff --git a/minidump/minidump_context_writer.h b/minidump/minidump_context_writer.h
index 6660be4..0a0fd49 100644
--- a/minidump/minidump_context_writer.h
+++ b/minidump/minidump_context_writer.h
@@ -369,6 +369,44 @@
   MinidumpContextMIPS64 context_;
 };
 
+//! \brief The writer for a MinidumpContextLOONGARCH64 structure in a minidump file.
+class MinidumpContextLOONGARCH64Writer final : public MinidumpContextWriter {
+ public:
+  MinidumpContextLOONGARCH64Writer();
+  ~MinidumpContextLOONGARCH64Writer() override;
+
+  //! \brief Initializes the MinidumpContextLOONGARCH based on \a context_snapshot.
+  //!
+  //! \param[in] context_snapshot The context snapshot to use as source data.
+  //!
+  //! \note Valid in #kStateMutable. No mutation of context() may be done before
+  //!     calling this method, and it is not normally necessary to alter
+  //!     context() after calling this method.
+  void InitializeFromSnapshot(const CPUContextLOONGARCH64* context_snapshot);
+
+  //! \brief Returns a pointer to the context structure that this object will
+  //!     write.
+  //!
+  //! \attention This returns a non-`const` pointer to this object’s private
+  //!     data so that a caller can populate the context structure directly.
+  //!     This is done because providing setter interfaces to each field in the
+  //!     context structure would be unwieldy and cumbersome. Care must be taken
+  //!     to populate the context structure correctly. The context structure
+  //!     must only be modified while this object is in the #kStateMutable
+  //!     state.
+  MinidumpContextLOONGARCH64* context() { return &context_; }
+
+ protected:
+  // MinidumpWritable:
+  bool WriteObject(FileWriterInterface* file_writer) override;
+
+  // MinidumpContextWriter:
+  size_t ContextSize() const override;
+
+ private:
+  MinidumpContextLOONGARCH64 context_;
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_WRITER_H_
diff --git a/minidump/minidump_context_writer_test.cc b/minidump/minidump_context_writer_test.cc
index e2a04d1..f8bb94d 100644
--- a/minidump/minidump_context_writer_test.cc
+++ b/minidump/minidump_context_writer_test.cc
@@ -268,6 +268,21 @@
                    TypeParam>(context, ExpectMinidumpContextMIPS64, kSeed);
 }
 
+TYPED_TEST(MinidumpContextWriter, LOONGARCH64_Zeros) {
+  EmptyContextTest<MinidumpContextLOONGARCH64Writer, MinidumpContextLOONGARCH64, TypeParam>(
+      ExpectMinidumpContextLOONGARCH64);
+}
+
+TYPED_TEST(MinidumpContextWriter, LOONGARCH64_FromSnapshot) {
+  constexpr uint32_t kSeed = 64;
+  CPUContextLOONGARCH64 context_loongarch64;
+  CPUContext context;
+  context.loongarch64 = &context_loongarch64;
+  InitializeCPUContextLOONGARCH64(&context, kSeed);
+  FromSnapshotTest<MinidumpContextLOONGARCH64Writer, MinidumpContextLOONGARCH64, TypeParam>(
+      context, ExpectMinidumpContextLOONGARCH64, kSeed);
+}
+
 }  // namespace
 }  // namespace test
 }  // namespace crashpad
diff --git a/minidump/minidump_extensions.h b/minidump/minidump_extensions.h
index 3cb0ca4..5f9f5f7 100644
--- a/minidump/minidump_extensions.h
+++ b/minidump/minidump_extensions.h
@@ -154,6 +154,7 @@
   kMinidumpCPUArchitectureX86 = PROCESSOR_ARCHITECTURE_INTEL,
 
   kMinidumpCPUArchitectureMIPS = PROCESSOR_ARCHITECTURE_MIPS,
+  kMinidumpCPUArchitectureLOONGARCH64 = PROCESSOR_ARCHITECTURE_LOONGARCH64,
   kMinidumpCPUArchitectureAlpha = PROCESSOR_ARCHITECTURE_ALPHA,
 
   //! \brief 32-bit PowerPC.
diff --git a/minidump/minidump_misc_info_writer.cc b/minidump/minidump_misc_info_writer.cc
index 133ae30..3246da6 100644
--- a/minidump/minidump_misc_info_writer.cc
+++ b/minidump/minidump_misc_info_writer.cc
@@ -175,6 +175,8 @@
   static constexpr char kCPU[] = "mips";
 #elif defined(ARCH_CPU_MIPS64EL)
   static constexpr char kCPU[] = "mips64";
+#elif defined(ARCH_CPU_LOONGARCH64)
+  static constexpr char kCPU[] = "loongarch64";
 #else
 #error define kCPU for this CPU
 #endif
diff --git a/minidump/test/minidump_context_test_util.cc b/minidump/test/minidump_context_test_util.cc
index 5746e4c..39661ab 100644
--- a/minidump/test/minidump_context_test_util.cc
+++ b/minidump/test/minidump_context_test_util.cc
@@ -272,6 +272,31 @@
   context->dsp_control = value++;
 }
 
+void InitializeMinidumpContextLOONGARCH64(MinidumpContextLOONGARCH64* context,
+                                     uint32_t seed) {
+  if (seed == 0) {
+    memset(context, 0, sizeof(*context));
+    context->context_flags = kMinidumpContextLOONGARCH64;
+    return;
+  }
+
+  context->context_flags = kMinidumpContextLOONGARCH64All;
+
+  uint64_t value = seed;
+
+  for (size_t index = 0; index < std::size(context->sc_regs); ++index) {
+    context->sc_regs[index] = value++;
+  }
+
+  context->sc_pc = value++;
+
+  for (size_t index = 0; index < std::size(context->fregs); ++index) {
+    context->fregs[index] = static_cast<double>(value++);
+  }
+  context->fcsr = value++;
+  context->fcc = value++;
+}
+
 namespace {
 
 // Using Google Test assertions, compares |expected| to |observed|. This is
@@ -601,5 +626,26 @@
   EXPECT_EQ(observed->dsp_control, expected.dsp_control);
 }
 
+void ExpectMinidumpContextLOONGARCH64(uint32_t expect_seed,
+                                 const MinidumpContextLOONGARCH64* observed,
+                                 bool snapshot) {
+  MinidumpContextLOONGARCH64 expected;
+  InitializeMinidumpContextLOONGARCH64(&expected, expect_seed);
+
+  EXPECT_EQ(observed->context_flags, expected.context_flags);
+
+  for (size_t index = 0; index < std::size(expected.sc_regs); ++index) {
+    EXPECT_EQ(observed->sc_regs[index], expected.sc_regs[index]);
+  }
+
+  EXPECT_EQ(observed->sc_pc, expected.sc_pc);
+
+  for (size_t index = 0; index < std::size(expected.fregs); ++index) {
+    EXPECT_EQ(observed->fregs[index], expected.fregs[index]);
+  }
+  EXPECT_EQ(observed->fcsr, expected.fcsr);
+  EXPECT_EQ(observed->fcc, expected.fcc);
+}
+
 }  // namespace test
 }  // namespace crashpad
diff --git a/minidump/test/minidump_context_test_util.h b/minidump/test/minidump_context_test_util.h
index 793e2c3..f2fc068 100644
--- a/minidump/test/minidump_context_test_util.h
+++ b/minidump/test/minidump_context_test_util.h
@@ -47,6 +47,8 @@
 void InitializeMinidumpContextMIPS(MinidumpContextMIPS* context, uint32_t seed);
 void InitializeMinidumpContextMIPS64(MinidumpContextMIPS* context,
                                      uint32_t seed);
+void InitializeMinidumpContextLOONGARCH64(MinidumpContextLOONGARCH64* context,
+                                     uint32_t seed);
 //! \}
 
 //! \brief Verifies, via Google Test assertions, that a context structure
@@ -85,6 +87,9 @@
 void ExpectMinidumpContextMIPS64(uint32_t expect_seed,
                                  const MinidumpContextMIPS64* observed,
                                  bool snapshot);
+void ExpectMinidumpContextLOONGARCH64(uint32_t expect_seed,
+                                 const MinidumpContextLOONGARCH64* observed,
+                                 bool snapshot);
 //! \}
 
 }  // namespace test
diff --git a/snapshot/BUILD.gn b/snapshot/BUILD.gn
index 09a3f78..a4070e3 100644
--- a/snapshot/BUILD.gn
+++ b/snapshot/BUILD.gn
@@ -468,7 +468,8 @@
   }
 
   if ((crashpad_is_linux || crashpad_is_android || crashpad_is_fuchsia) &&
-      target_cpu != "mipsel" && target_cpu != "mips64el") {
+      target_cpu != "mipsel" && target_cpu != "mips64el" &&
+      target_cpu != "loongarch64") {
     data_deps += [ ":crashpad_snapshot_test_both_dt_hash_styles" ]
   }
 
@@ -536,7 +537,8 @@
 }
 
 if ((crashpad_is_linux || crashpad_is_android || crashpad_is_fuchsia) &&
-    target_cpu != "mipsel" && target_cpu != "mips64el") {
+    target_cpu != "mipsel" && target_cpu != "mips64el" &&
+      target_cpu != "loongarch64") {
   crashpad_loadable_module("crashpad_snapshot_test_both_dt_hash_styles") {
     testonly = true
     sources = [ "hash_types_test.cc" ]
diff --git a/snapshot/capture_memory.cc b/snapshot/capture_memory.cc
index 0a465d2..a188b86 100644
--- a/snapshot/capture_memory.cc
+++ b/snapshot/capture_memory.cc
@@ -117,6 +117,10 @@
   for (size_t i = 0; i < std::size(context.mipsel->regs); ++i) {
     MaybeCaptureMemoryAround(delegate, context.mipsel->regs[i]);
   }
+#elif defined(ARCH_CPU_LOONGARCH64)
+  for (size_t i = 0; i < std::size(context.loongarch64->sc_regs); ++i) {
+    MaybeCaptureMemoryAround(delegate, context.loongarch64->sc_regs[i]);
+  }
 #else
 #error Port.
 #endif
diff --git a/snapshot/cpu_architecture.h b/snapshot/cpu_architecture.h
index 4003a92..24ca410 100644
--- a/snapshot/cpu_architecture.h
+++ b/snapshot/cpu_architecture.h
@@ -43,7 +43,10 @@
   kCPUArchitectureMIPSEL,
 
   //! \brief 64-bit MIPSEL.
-  kCPUArchitectureMIPS64EL
+  kCPUArchitectureMIPS64EL,
+
+  //! \brief 64-bit LOONGARCH.
+  kCPUArchitectureLOONGARCH64,
 };
 
 }  // namespace crashpad
diff --git a/snapshot/cpu_context.cc b/snapshot/cpu_context.cc
index 6eaa853..0c07e75 100644
--- a/snapshot/cpu_context.cc
+++ b/snapshot/cpu_context.cc
@@ -170,6 +170,8 @@
       return arm->pc;
     case kCPUArchitectureARM64:
       return arm64->pc;
+    case kCPUArchitectureLOONGARCH64:
+      return loongarch64->sc_pc;
     default:
       NOTREACHED();
       return ~0ull;
@@ -186,6 +188,8 @@
       return arm->sp;
     case kCPUArchitectureARM64:
       return arm64->sp;
+    case kCPUArchitectureLOONGARCH64:
+      return loongarch64->sc_regs[3];
     default:
       NOTREACHED();
       return ~0ull;
@@ -226,6 +230,7 @@
     case kCPUArchitectureX86_64:
     case kCPUArchitectureARM64:
     case kCPUArchitectureMIPS64EL:
+    case kCPUArchitectureLOONGARCH64:
       return true;
     case kCPUArchitectureX86:
     case kCPUArchitectureARM:
diff --git a/snapshot/cpu_context.h b/snapshot/cpu_context.h
index 7bc252b..e92fbc8 100644
--- a/snapshot/cpu_context.h
+++ b/snapshot/cpu_context.h
@@ -362,6 +362,15 @@
   uint64_t fir;
 };
 
+//! \brief A context structure carrying LOONGARCH64 CPU state.
+struct CPUContextLOONGARCH64 {
+  uint64_t sc_pc;
+  uint64_t sc_regs[32];
+  uint64_t fregs[32];
+  uint64_t fcc;
+  uint32_t fcsr;
+};
+
 //! \brief A context structure capable of carrying the context of any supported
 //!     CPU architecture.
 struct CPUContext {
@@ -402,6 +411,7 @@
     CPUContextARM64* arm64;
     CPUContextMIPS* mipsel;
     CPUContextMIPS64* mips64;
+    CPUContextLOONGARCH64* loongarch64;
   };
 };
 
diff --git a/snapshot/elf/elf_image_reader.cc b/snapshot/elf/elf_image_reader.cc
index 30e8b98..8933b6f 100644
--- a/snapshot/elf/elf_image_reader.cc
+++ b/snapshot/elf/elf_image_reader.cc
@@ -593,6 +593,7 @@
     return false;
   }
 
+#if !defined(__loongarch64)
   // GNU ld.so doesn't adjust the vdso's dynamic array entries by the load bias.
   // If the address is too small to point into the loaded module range and is
   // small enough to be an offset from the base of the module, adjust it now.
@@ -600,6 +601,11 @@
       string_table_address < memory_.Size()) {
     string_table_address += GetLoadBias();
   }
+#else
+  // LoongArch ABI specifies that the dynamic section has to be read-only.
+  // See glibc: sysdeps/loongarch/ldsodefs.h
+  string_table_address += GetLoadBias();
+#endif
 
   if (!memory_.ReadCStringSizeLimited(
           string_table_address + offset, string_table_size - offset, string)) {
@@ -754,6 +760,10 @@
     return false;
   }
 
+#if defined(__loongarch64)
+  dt_hash_address += GetLoadBias();
+#endif
+
   struct {
     uint32_t nbucket;
     uint32_t nchain;
@@ -779,6 +789,10 @@
     return false;
   }
 
+#if defined(__loongarch64)
+  dt_gnu_hash_address += GetLoadBias();
+#endif
+
   // See https://flapenguin.me/2017/05/10/elf-lookup-dt-gnu-hash/ and
   // https://sourceware.org/ml/binutils/2006-10/msg00377.html.
   struct {
diff --git a/snapshot/elf/elf_symbol_table_reader.cc b/snapshot/elf/elf_symbol_table_reader.cc
index 4c59d74..3af0950 100644
--- a/snapshot/elf/elf_symbol_table_reader.cc
+++ b/snapshot/elf/elf_symbol_table_reader.cc
@@ -72,16 +72,25 @@
   SymEnt entry;
   std::string string;
   size_t i = 0;
+  const char vdso_prefix[] = "__vdso_";
+
+#if defined(__loongarch64)
+  address += elf_reader_->GetLoadBias();
+#endif
+
   while (i < num_entries_ && memory_->Read(address, sizeof(entry), &entry)) {
-    if (elf_reader_->ReadDynamicStringTableAtOffset(entry.st_name, &string) &&
-        string == name) {
-      info_out->address = entry.st_value;
-      info_out->size = entry.st_size;
-      info_out->shndx = entry.st_shndx;
-      info_out->binding = GetBinding(entry);
-      info_out->type = GetType(entry);
-      info_out->visibility = GetVisibility(entry);
-      return true;
+    if (elf_reader_->ReadDynamicStringTableAtOffset(entry.st_name, &string)) {
+      if (string.find(vdso_prefix) == 0)
+        string.erase(0, sizeof(vdso_prefix) - 1);
+      if (string == name) {
+        info_out->address = entry.st_value;
+        info_out->size = entry.st_size;
+        info_out->shndx = entry.st_shndx;
+        info_out->binding = GetBinding(entry);
+        info_out->type = GetType(entry);
+        info_out->visibility = GetVisibility(entry);
+        return true;
+      }
     }
     // TODO(scottmg): This should respect DT_SYMENT if present.
     address += sizeof(entry);
diff --git a/snapshot/linux/cpu_context_linux.cc b/snapshot/linux/cpu_context_linux.cc
index 21db234..eefe8f8 100644
--- a/snapshot/linux/cpu_context_linux.cc
+++ b/snapshot/linux/cpu_context_linux.cc
@@ -265,7 +265,31 @@
   context->fpsr = float_context.fpsr;
   context->fpcr = float_context.fpcr;
 }
+#elif defined(ARCH_CPU_LOONGARCH64)
+void InitializeCPUContextLOONGARCH64(const ThreadContext::t64_t& thread_context,
+                               const FloatContext::f64_t& float_context,
+                               CPUContextLOONGARCH64* context) {
+  InitializeCPUContextLOONGARCH64_NoFloatingPoint(thread_context, context);
 
+  static_assert(sizeof(context->fregs) == sizeof(float_context.fregs),
+                "fpu context size mismatch");
+  memcpy(context->fregs, float_context.fregs, sizeof(context->fregs));
+  context->fcc = float_context.fcc;
+  context->fcsr = float_context.fcsr;
+}
+
+void InitializeCPUContextLOONGARCH64_NoFloatingPoint(
+    const ThreadContext::t64_t& thread_context,
+    CPUContextLOONGARCH64* context) {
+  static_assert(sizeof(context->sc_regs) == sizeof(thread_context.regs),
+                "gpr context size mismtach");
+  memcpy(context->sc_regs, thread_context.regs, sizeof(context->sc_regs));
+  context->sc_pc = thread_context.csr_era;
+
+  memset(&context->fregs, 0, sizeof(context->fregs));
+  context->fcc = 0;
+  context->fcsr = 0;
+}
 #endif  // ARCH_CPU_X86_FAMILY
 
 }  // namespace internal
diff --git a/snapshot/linux/cpu_context_linux.h b/snapshot/linux/cpu_context_linux.h
index 1ea5eec..0afcc3c 100644
--- a/snapshot/linux/cpu_context_linux.h
+++ b/snapshot/linux/cpu_context_linux.h
@@ -174,6 +174,30 @@
 
 #endif  // ARCH_CPU_MIPS_FAMILY || DOXYGEN
 
+#if defined(ARCH_CPU_LOONGARCH64) || DOXYGEN
+//! \brief Initializes a CPUContextARM64 structure from native context
+//!     structures on Linux.
+//!
+//! \param[in] thread_context The native thread context.
+//! \param[in] float_context The native float context.
+//! \param[out] context The CPUContextARM64 structure to initialize.
+void InitializeCPUContextLOONGARCH64(const ThreadContext::t64_t& thread_context,
+                               const FloatContext::f64_t& float_context,
+                               CPUContextLOONGARCH64* context);
+
+//! \brief Initializes GPR state in a CPUContextARM64 from a native context
+//!     structure on Linux.
+//!
+//! Floating point state is initialized to zero.
+//!
+//! \param[in] thread_context The native thread context.
+//! \param[out] context The CPUContextARM64 structure to initialize.
+void InitializeCPUContextLOONGARCH64_NoFloatingPoint(
+    const ThreadContext::t64_t& thread_context,
+    CPUContextLOONGARCH64* context);
+
+#endif  // ARCH_CPU_LOONGARCH64 || DOXYGEN
+
 }  // namespace internal
 }  // namespace crashpad
 
diff --git a/snapshot/linux/exception_snapshot_linux.cc b/snapshot/linux/exception_snapshot_linux.cc
index 4e6ec11..a6237aa 100644
--- a/snapshot/linux/exception_snapshot_linux.cc
+++ b/snapshot/linux/exception_snapshot_linux.cc
@@ -325,6 +325,78 @@
       reader, context_address, context_.mips64);
 }
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+
+template <typename Traits>
+static bool ReadContext(ProcessReaderLinux* reader,
+                        LinuxVMAddress context_address,
+                        typename Traits::CPUContext* dest_context) {
+  const ProcessMemory* memory = reader->Memory();
+
+  LinuxVMAddress gregs_address = context_address +
+                                 offsetof(UContext<Traits>, mcontext) +
+                                 offsetof(typename Traits::MContext, gregs);
+
+  typename Traits::SignalThreadContext thread_context;
+  if (!memory->Read(gregs_address, sizeof(thread_context), &thread_context)) {
+    LOG(ERROR) << "Couldn't read gregs";
+    return false;
+  }
+
+  LinuxVMAddress reserved_address =
+      context_address + offsetof(typename Traits::MContext, sc_extcontext);
+  if ((reserved_address & 15) != 0) {
+    LOG(ERROR) << "invalid alignment 0x" << std::hex << reserved_address;
+    return false;
+  }
+
+  constexpr VMSize kMaxContextSpace = 4096;
+
+  ProcessMemoryRange range;
+  if (!range.Initialize(memory, true, reserved_address, kMaxContextSpace)) {
+    return false;
+  }
+
+  do {
+    SCTXInfo sctx;
+    if (!range.Read(reserved_address, sizeof(sctx), &sctx)) {
+      LOG(ERROR) << "missing context sctx";
+      return false;
+    }
+
+    switch (sctx.magic) {
+      case FPU_CTX_MAGIC:
+        FPUContext fpu;
+        if (!range.Read(reserved_address, sizeof(fpu), &fpu)) {
+          LOG(ERROR) << "Couldn't read fpu " << sctx.size;
+          return false;
+        }
+        return true;
+      case 0:
+        LOG(WARNING) << "fpu not found";
+        return true;
+
+      default:
+        LOG(ERROR) << "invalid magic number 0x" << std::hex << sctx.magic;
+        return false;
+    }
+  } while (true);
+
+  return true;
+
+}
+
+template <>
+bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
+    ProcessReaderLinux* reader,
+    LinuxVMAddress context_address) {
+  context_.architecture = kCPUArchitectureLOONGARCH64;
+  context_.loongarch64 = &context_union_.loongarch64;
+
+  return internal::ReadContext<ContextTraits64>(
+      reader, context_address, context_.loongarch64);
+}
+
 #endif  // ARCH_CPU_X86_FAMILY
 
 bool ExceptionSnapshotLinux::Initialize(
@@ -354,12 +426,15 @@
         !ReadSiginfo<Traits64>(process_reader, siginfo_address)) {
       return false;
     }
-  } else {
+  }
+#if !defined(ARCH_CPU_LOONGARCH64)
+  else {
     if (!ReadContext<ContextTraits32>(process_reader, context_address) ||
         !ReadSiginfo<Traits32>(process_reader, siginfo_address)) {
       return false;
     }
   }
+#endif
 
   CaptureMemoryDelegateLinux capture_memory_delegate(
       process_reader,
diff --git a/snapshot/linux/exception_snapshot_linux.h b/snapshot/linux/exception_snapshot_linux.h
index 3ea3d93..f0b2443 100644
--- a/snapshot/linux/exception_snapshot_linux.h
+++ b/snapshot/linux/exception_snapshot_linux.h
@@ -89,6 +89,8 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
     CPUContextMIPS mipsel;
     CPUContextMIPS64 mips64;
+#elif defined(ARCH_CPU_LOONGARCH64)
+    CPUContextLOONGARCH64 loongarch64;
 #endif
   } context_union_;
   CPUContext context_;
diff --git a/snapshot/linux/exception_snapshot_linux_test.cc b/snapshot/linux/exception_snapshot_linux_test.cc
index 0f5e21a..b21f42b 100644
--- a/snapshot/linux/exception_snapshot_linux_test.cc
+++ b/snapshot/linux/exception_snapshot_linux_test.cc
@@ -296,6 +296,48 @@
             0);
 #undef CPU_ARCH_NAME
 }
+#elif defined(ARCH_CPU_LOONGARCH64)
+using NativeCPUContext = ucontext_t;
+struct TestCoprocessorContext {
+  sctx_info sctx;
+  fpu_context fpu;
+};
+
+void InitializeContext(NativeCPUContext* context) {
+  context->uc_mcontext.__pc = 1;
+  for (size_t reg = 0; reg < std::size(context->uc_mcontext.__gregs); ++reg) {
+    context->uc_mcontext.__gregs[reg] = reg;
+  }
+
+auto test_context = reinterpret_cast<TestCoprocessorContext*>(
+      context->uc_mcontext.__extcontext);
+  test_context->sctx.magic = 0;
+  test_context->sctx.size = 0;;
+
+  for (size_t reg = 0; reg < std::size(test_context->fpu.regs); ++reg) {
+    test_context->fpu.regs[reg] = reg;
+
+  test_context->fpu.fcc = 1;
+  test_context->fpu.fcsr = 2;
+  }
+}
+
+void ExpectContext(const CPUContext& actual, const NativeCPUContext& expected) {
+  EXPECT_EQ(actual.architecture, kCPUArchitectureLOONGARCH64);
+
+  auto test_context = reinterpret_cast< const TestCoprocessorContext*>(
+       expected.uc_mcontext.__extcontext);
+  for (size_t reg = 0; reg < std::size(expected.uc_mcontext.__gregs); ++reg) {
+    EXPECT_EQ(actual.loongarch64->sc_regs[reg], expected.uc_mcontext.__gregs[reg]);
+  }
+
+  EXPECT_EQ(memcmp(&actual.loongarch64->fregs,
+                   &test_context->fpu.regs,
+                   sizeof(actual.loongarch64->fregs)),
+            0);
+  EXPECT_EQ(actual.loongarch64->fcc, test_context->fpu.fcc);
+  EXPECT_EQ(actual.loongarch64->fcsr, test_context->fpu.fcsr);
+}
 
 #else
 #error Port.
diff --git a/snapshot/linux/process_reader_linux.cc b/snapshot/linux/process_reader_linux.cc
index 8ec0edc..1b1bb7e 100644
--- a/snapshot/linux/process_reader_linux.cc
+++ b/snapshot/linux/process_reader_linux.cc
@@ -127,6 +127,8 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   stack_pointer = reader->Is64Bit() ? thread_info.thread_context.t64.regs[29]
                                     : thread_info.thread_context.t32.regs[29];
+#elif defined(ARCH_CPU_LOONGARCH64)
+  stack_pointer = thread_info.thread_context.t64.regs[3];
 #else
 #error Port.
 #endif
diff --git a/snapshot/linux/signal_context.h b/snapshot/linux/signal_context.h
index 6ac7ade..5bcd3c5 100644
--- a/snapshot/linux/signal_context.h
+++ b/snapshot/linux/signal_context.h
@@ -420,8 +420,45 @@
 static_assert(offsetof(UContext<ContextTraits64>, mcontext.fpregs) ==
                   offsetof(ucontext_t, uc_mcontext.fpregs),
               "context offset mismatch");
-#endif
+#endif // ARCH_CPU_MIPSEL
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+
+struct MContext64 {
+  uint64_t sc_pc;
+  uint64_t gregs[32];
+  uint32_t sc_flags;
+  uint64_t sc_extcontext[0] __attribute__((__aligned__(16)));
+};
+
+struct SCTXInfo {
+  uint32_t magic;
+  uint32_t size;
+  uint64_t padding;
+};
+
+struct FPUContext {
+  uint64_t regs[32];
+  uint64_t fcc;
+  uint32_t fcsr;
+};
+
+struct ContextTraits64 : public Traits64 {
+  using MContext = MContext64;
+  using SignalThreadContext = ThreadContext::t64_t;
+  using SignalFloatContext = FloatContext::f64_t;
+  using CPUContext = CPUContextLOONGARCH64;
+};
+
+template <typename Traits>
+struct UContext {
+  typename Traits::ULong flags;
+  typename Traits::Address link;
+  SignalStack<Traits> stack;
+  Sigset<Traits> sigmask;
+  char padding[128 - sizeof(sigmask)];
+  typename Traits::MContext mcontext;
+};
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/snapshot/linux/system_snapshot_linux.cc b/snapshot/linux/system_snapshot_linux.cc
index 9d199ff..ea2858b 100644
--- a/snapshot/linux/system_snapshot_linux.cc
+++ b/snapshot/linux/system_snapshot_linux.cc
@@ -205,6 +205,8 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return process_reader_->Is64Bit() ? kCPUArchitectureMIPS64EL
                                     : kCPUArchitectureMIPSEL;
+#elif defined(ARCH_CPU_LOONGARCH64)
+  return kCPUArchitectureLOONGARCH64;
 #else
 #error port to your architecture
 #endif
@@ -220,6 +222,9 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return 0;
+#elif defined(ARCH_CPU_LOONGARCH64)
+  // Not implementable on LOONGARCH64
+  return 0;
 #else
 #error port to your architecture
 #endif
@@ -240,6 +245,9 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return std::string();
+#elif defined(ARCH_CPU_LOONGARCH64)
+  // Not implementable on LOONGARCH64
+  return std::string();
 #else
 #error port to your architecture
 #endif
@@ -373,6 +381,9 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return false;
+#elif defined(ARCH_CPU_LOONGARCH64)
+  // Not implementable on LOONGARCH64
+  return false;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/snapshot/linux/test_modules.cc b/snapshot/linux/test_modules.cc
index 7d9d08d..21c12b7 100644
--- a/snapshot/linux/test_modules.cc
+++ b/snapshot/linux/test_modules.cc
@@ -110,6 +110,9 @@
   module.ehdr.e_machine = EM_AARCH64;
 #elif defined(ARCH_CPU_MIPSEL) || defined(ARCH_CPU_MIPS64EL)
   module.ehdr.e_machine = EM_MIPS;
+#elif defined(ARCH_CPU_LOONGARCH64)
+  module.ehdr.e_machine = EM_LOONGARCH;
+  module.ehdr.e_flags |= EF_LARCH_ABI_LP64D;
 #endif
 
   module.ehdr.e_version = EV_CURRENT;
diff --git a/snapshot/linux/thread_snapshot_linux.cc b/snapshot/linux/thread_snapshot_linux.cc
index ba33401..b3aa76f 100644
--- a/snapshot/linux/thread_snapshot_linux.cc
+++ b/snapshot/linux/thread_snapshot_linux.cc
@@ -190,6 +190,12 @@
         thread.thread_info.float_context.f32,
         context_.mipsel);
   }
+#elif defined(ARCH_CPU_LOONGARCH64)
+  context_.architecture = kCPUArchitectureLOONGARCH64;
+  context_.loongarch64 = &context_union_.loongarch64;
+  InitializeCPUContextLOONGARCH64(thread.thread_info.thread_context.t64,
+				  thread.thread_info.float_context.f64,
+				  context_.loongarch64);
 #else
 #error Port.
 #endif
diff --git a/snapshot/linux/thread_snapshot_linux.h b/snapshot/linux/thread_snapshot_linux.h
index bd03f58..7a7473c 100644
--- a/snapshot/linux/thread_snapshot_linux.h
+++ b/snapshot/linux/thread_snapshot_linux.h
@@ -74,6 +74,8 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
     CPUContextMIPS mipsel;
     CPUContextMIPS64 mips64;
+#elif defined(ARCH_CPU_LOONGARCH64)
+    CPUContextLOONGARCH64 loongarch64;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/snapshot/minidump/minidump_context_converter.cc b/snapshot/minidump/minidump_context_converter.cc
index f2fa2ab..9b749a5 100644
--- a/snapshot/minidump/minidump_context_converter.cc
+++ b/snapshot/minidump/minidump_context_converter.cc
@@ -266,6 +266,28 @@
     context_.mips64->fir = src->fir;
 
     memcpy(&context_.mips64->fpregs, &src->fpregs, sizeof(src->fpregs));
+  } else if (context_.architecture ==
+             CPUArchitecture::kCPUArchitectureLOONGARCH64) {
+    context_memory_.resize(sizeof(CPUContextLOONGARCH64));
+    context_.loongarch64 =
+        reinterpret_cast<CPUContextLOONGARCH64*>(context_memory_.data());
+    const MinidumpContextLOONGARCH64* src =
+        reinterpret_cast<const MinidumpContextLOONGARCH64*>(minidump_context.data());
+    if (minidump_context.size() < sizeof(MinidumpContextLOONGARCH64)) {
+      return false;
+    }
+
+    if (!(src->context_flags & kMinidumpContextLOONGARCH64)) {
+      return false;
+    }
+
+    for (size_t i = 0; i < std::size(src->sc_regs); i++) {
+      context_.loongarch64->sc_regs[i] = src->sc_regs[i];
+    }
+
+    context_.loongarch64->sc_pc = src->sc_pc;
+    context_.loongarch64->fcsr = src->fcsr;
+    context_.loongarch64->fcc = src->fcc;
   } else {
     // Architecture is listed as "unknown".
     DLOG(ERROR) << "Unknown architecture";
diff --git a/snapshot/minidump/system_snapshot_minidump.cc b/snapshot/minidump/system_snapshot_minidump.cc
index e6007b1..db771d5 100644
--- a/snapshot/minidump/system_snapshot_minidump.cc
+++ b/snapshot/minidump/system_snapshot_minidump.cc
@@ -68,7 +68,8 @@
     case kMinidumpCPUArchitectureMIPS:
       return kCPUArchitectureMIPSEL;
     // No word on how MIPS64 is signalled
-
+    case kMinidumpCPUArchitectureLOONGARCH64:
+      return kCPUArchitectureLOONGARCH64;
     default:
       return CPUArchitecture::kCPUArchitectureUnknown;
   }
diff --git a/snapshot/test/test_cpu_context.cc b/snapshot/test/test_cpu_context.cc
index 7efbf5a..37514de 100644
--- a/snapshot/test/test_cpu_context.cc
+++ b/snapshot/test/test_cpu_context.cc
@@ -295,5 +295,25 @@
   mips64->dsp_control = value++;
 }
 
+void InitializeCPUContextLOONGARCH64(CPUContext* context, uint32_t seed) {
+  context->architecture = kCPUArchitectureLOONGARCH64;
+  CPUContextLOONGARCH64* loongarch64 = context->loongarch64;
+
+  if (seed == 0) {
+    memset(loongarch64, 0, sizeof(*loongarch64));
+    return;
+  }
+
+  uint64_t value = seed;
+
+  for (size_t index = 0; index < std::size(loongarch64->fregs); ++index) {
+    loongarch64->fregs[index] = value++;
+  }
+
+  loongarch64->sc_pc = value++;
+  loongarch64->fcsr = value++;
+  loongarch64->fcc = value++;
+}
+
 }  // namespace test
 }  // namespace crashpad
diff --git a/snapshot/test/test_cpu_context.h b/snapshot/test/test_cpu_context.h
index e4372ce..ed5af67 100644
--- a/snapshot/test/test_cpu_context.h
+++ b/snapshot/test/test_cpu_context.h
@@ -63,6 +63,7 @@
 void InitializeCPUContextARM64(CPUContext* context, uint32_t seed);
 void InitializeCPUContextMIPS(CPUContext* context, uint32_t seed);
 void InitializeCPUContextMIPS64(CPUContext* context, uint32_t seed);
+void InitializeCPUContextLOONGARCH64(CPUContext* context, uint32_t seed);
 //! \}
 
 }  // namespace test
diff --git a/test/linux/get_tls.cc b/test/linux/get_tls.cc
index c8147f0..47e945f 100644
--- a/test/linux/get_tls.cc
+++ b/test/linux/get_tls.cc
@@ -49,6 +49,11 @@
       : "=r"(tls)
       :
       : "$3");
+#elif defined(ARCH_CPU_LOONGARCH64)
+  asm("move    %0,$tp\n\t"
+      : "=r"(tls)
+      :
+      : "$3");
 #else
 #error Port.
 #endif  // ARCH_CPU_ARMEL
diff --git a/test/multiprocess_posix.cc b/test/multiprocess_posix.cc
index eb7cf9c..b1a27c9 100644
--- a/test/multiprocess_posix.cc
+++ b/test/multiprocess_posix.cc
@@ -162,7 +162,8 @@
 }
 
 void Multiprocess::SetExpectedChildTerminationBuiltinTrap() {
-#if defined(ARCH_CPU_ARM64) || defined(ARCH_CPU_MIPS_FAMILY)
+#if defined(ARCH_CPU_ARM64) || defined(ARCH_CPU_MIPS_FAMILY) ||\
+    defined (ARCH_CPU_LOONGARCH64)
   SetExpectedChildTermination(kTerminationSignal, SIGTRAP);
 #else
   SetExpectedChildTermination(kTerminationSignal, SIGILL);
diff --git a/util/linux/ptracer.cc b/util/linux/ptracer.cc
index 25c89ea..485f04a 100644
--- a/util/linux/ptracer.cc
+++ b/util/linux/ptracer.cc
@@ -398,6 +398,54 @@
   return true;
 }
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+
+bool GetFloatingPointRegisters32(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) {
+  return false;
+}
+
+bool GetFloatingPointRegisters64(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) {
+  iovec iov;
+  iov.iov_base = context;
+  iov.iov_len = sizeof(*context);
+  if (ptrace(PTRACE_GETREGSET, tid, reinterpret_cast<void*>(NT_PRFPREG), &iov) != 0) {
+    PLOG_IF(ERROR, can_log) << "ptrace";
+    return false;
+  }
+  if (iov.iov_len != sizeof(context->f64)) {
+    LOG_IF(ERROR, can_log) << "Unexpected registers size " << iov.iov_len
+                           << " != " << sizeof(context->f64);
+    return false;
+  }
+
+  return true;
+}
+
+bool GetThreadArea32(pid_t tid,
+                     const ThreadContext& context,
+                     LinuxVMAddress* address,
+                     bool can_log) {
+  return false;
+}
+
+bool GetThreadArea64(pid_t tid,
+                     const ThreadContext& context,
+                     LinuxVMAddress* address,
+                     bool can_log) {
+  void* result;
+
+  if (ptrace(PTRACE_GET_THREAD_AREA, tid, nullptr, &result) != 0) {
+    PLOG_IF(ERROR, can_log) << "ptrace";
+    return false;
+  }
+  *address = FromPointerCast<LinuxVMAddress>(result);
+  return true;
+}
+
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/util/linux/thread_info.h b/util/linux/thread_info.h
index 8b94eff..aaea65f 100644
--- a/util/linux/thread_info.h
+++ b/util/linux/thread_info.h
@@ -79,6 +79,8 @@
     uint32_t cp0_status;
     uint32_t cp0_cause;
     uint32_t padding1_;
+#elif defined(ARCH_CPU_LOONGARCH64)
+    // Nothing.
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -132,6 +134,11 @@
     uint64_t cp0_badvaddr;
     uint64_t cp0_status;
     uint64_t cp0_cause;
+#elif defined(ARCH_CPU_LOONGARCH64)
+    // Reflects user_regs_struct in sys/user.h.
+    uint64_t regs[32];
+    uint64_t csr_era;
+    uint64_t _pad[12];
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -141,13 +148,13 @@
   using NativeThreadContext = user_regs_struct;
 #elif defined(ARCH_CPU_ARMEL)
   using NativeThreadContext = user_regs;
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined (ARCH_CPU_LOONGARCH64)
 // No appropriate NativeThreadsContext type available for MIPS
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY || ARCH_CPU_ARM64
 
-#if !defined(ARCH_CPU_MIPS_FAMILY)
+#if !defined(ARCH_CPU_MIPS_FAMILY) && !defined(ARCH_CPU_LOONGARCH64)
 #if defined(ARCH_CPU_32_BITS)
   static_assert(sizeof(t32_t) == sizeof(NativeThreadContext), "Size mismatch");
 #else  // ARCH_CPU_64_BITS
@@ -218,6 +225,8 @@
     } fpregs[32];
     uint32_t fpcsr;
     uint32_t fpu_id;
+#elif defined(ARCH_CPU_LOONGARCH64)
+    // Nothing.
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -252,6 +261,10 @@
     double fpregs[32];
     uint32_t fpcsr;
     uint32_t fpu_id;
+#elif defined(ARCH_CPU_LOONGARCH64)
+    uint64_t fregs[32];
+    uint32_t fcsr;
+    uint64_t fcc;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -279,7 +292,7 @@
 #endif
 #elif defined(ARCH_CPU_ARM64)
   static_assert(sizeof(f64) == sizeof(user_fpsimd_struct), "Size mismatch");
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined (ARCH_CPU_LOONGARCH64)
 // No appropriate floating point context native type for available MIPS.
 #else
 #error Port.
diff --git a/util/misc/capture_context.h b/util/misc/capture_context.h
index a5503d6..668be84 100644
--- a/util/misc/capture_context.h
+++ b/util/misc/capture_context.h
@@ -69,6 +69,7 @@
 //!     macOS/Linux/Fuchsia | x86_64       | `%%rdi`
 //!     Linux               | ARM/ARM64    | `r0`/`x0`
 //!     Linux               | MIPS/MIPS64  | `$a0`
+//!     Linux               | LOONGARCH64  | `$a0`
 //!
 //!     Additionally, the value `LR` on ARM/ARM64 will be the return address of
 //!     this function.
diff --git a/util/misc/capture_context_linux.S b/util/misc/capture_context_linux.S
index 9c3a726..58e9dba 100644
--- a/util/misc/capture_context_linux.S
+++ b/util/misc/capture_context_linux.S
@@ -30,7 +30,7 @@
   .globl CAPTURECONTEXT_SYMBOL2
 #if defined(__i386__) || defined(__x86_64__)
   .balign 16, 0x90
-#elif defined(__arm__) || defined(__aarch64__)
+#elif defined(__arm__) || defined(__aarch64__) || defined(__loongarch64)
   .balign 4, 0x0
   .type CAPTURECONTEXT_SYMBOL, %function
   .type CAPTURECONTEXT_SYMBOL2, %function
@@ -427,4 +427,83 @@
   jr $ra
 
   .set at
+#elif defined(__loongarch64)
+
+#define MCONTEXT_GREG_SIZE 8
+#define MCONTEXT_FPREG_SIZE 8
+#define MCONTEXT_PC_OFFSET 64
+#define MCONTEXT_GREGS_OFFSET 72
+#define MCONTEXT_FPREGS_OFFSET 352
+
+#define STORE_GPR(X) st.d $r##X, $a0, MCONTEXT_GREGS_OFFSET + X * MCONTEXT_GREG_SIZE
+#define STORE_FPR(X) fst.d $f##X, $a0, MCONTEXT_FPREGS_OFFSET + X * MCONTEXT_FPREG_SIZE
+#define STORE_PC st.d $ra, $a0, MCONTEXT_PC_OFFSET
+
+  STORE_PC
+  STORE_GPR(0)
+  STORE_GPR(1)
+  STORE_GPR(2)
+  STORE_GPR(3)
+  STORE_GPR(4)
+  STORE_GPR(5)
+  STORE_GPR(6)
+  STORE_GPR(7)
+  STORE_GPR(8)
+  STORE_GPR(9)
+  STORE_GPR(10)
+  STORE_GPR(11)
+  STORE_GPR(12)
+  STORE_GPR(13)
+  STORE_GPR(14)
+  STORE_GPR(15)
+  STORE_GPR(16)
+  STORE_GPR(17)
+  STORE_GPR(18)
+  STORE_GPR(19)
+  STORE_GPR(20)
+  STORE_GPR(21)
+  STORE_GPR(22)
+  STORE_GPR(23)
+  STORE_GPR(24)
+  STORE_GPR(25)
+  STORE_GPR(26)
+  STORE_GPR(27)
+  STORE_GPR(28)
+  STORE_GPR(29)
+  STORE_GPR(30)
+  STORE_GPR(31)
+  STORE_FPR(0)
+  STORE_FPR(1)
+  STORE_FPR(2)
+  STORE_FPR(3)
+  STORE_FPR(4)
+  STORE_FPR(5)
+  STORE_FPR(6)
+  STORE_FPR(7)
+  STORE_FPR(8)
+  STORE_FPR(9)
+  STORE_FPR(10)
+  STORE_FPR(11)
+  STORE_FPR(12)
+  STORE_FPR(13)
+  STORE_FPR(14)
+  STORE_FPR(15)
+  STORE_FPR(16)
+  STORE_FPR(17)
+  STORE_FPR(18)
+  STORE_FPR(19)
+  STORE_FPR(20)
+  STORE_FPR(21)
+  STORE_FPR(22)
+  STORE_FPR(23)
+  STORE_FPR(24)
+  STORE_FPR(25)
+  STORE_FPR(26)
+  STORE_FPR(27)
+  STORE_FPR(28)
+  STORE_FPR(29)
+  STORE_FPR(30)
+  STORE_FPR(31)
+
+  jirl $zero, $ra, 0
 #endif  // __i386__
diff --git a/util/misc/capture_context_test.cc b/util/misc/capture_context_test.cc
index f353aeb..892d521 100644
--- a/util/misc/capture_context_test.cc
+++ b/util/misc/capture_context_test.cc
@@ -57,7 +57,7 @@
   uintptr_t pc = ProgramCounterFromContext(context_1);
 
 #if !defined(ADDRESS_SANITIZER) && !defined(ARCH_CPU_MIPS_FAMILY) && \
-    !defined(MEMORY_SANITIZER)
+    !defined(MEMORY_SANITIZER) && !defined(ARCH_CPU_LOONGARCH64)
   // Sanitizers can cause enough code bloat that the “nearby” check would
   // likely fail.
   const uintptr_t kReferencePC =
diff --git a/util/misc/capture_context_test_util_linux.cc b/util/misc/capture_context_test_util_linux.cc
index 35751bf..28c5fb0 100644
--- a/util/misc/capture_context_test_util_linux.cc
+++ b/util/misc/capture_context_test_util_linux.cc
@@ -35,6 +35,8 @@
   EXPECT_EQ(context.uc_mcontext.regs[0], FromPointerCast<uintptr_t>(&context));
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   EXPECT_EQ(context.uc_mcontext.gregs[4], FromPointerCast<uintptr_t>(&context));
+#elif defined(ARCH_CPU_LOONGARCH64)
+  EXPECT_EQ(context.uc_mcontext.__gregs[4], FromPointerCast<uintptr_t>(&context));
 #endif
 }
 
@@ -49,6 +51,8 @@
   return context.uc_mcontext.pc;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return context.uc_mcontext.pc;
+#elif defined(ARCH_CPU_LOONGARCH64)
+  return context.uc_mcontext.__pc;
 #endif
 }
 
@@ -63,6 +67,8 @@
   return context.uc_mcontext.sp;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return context.uc_mcontext.gregs[29];
+#elif defined(ARCH_CPU_LOONGARCH64)
+  return context.uc_mcontext.__gregs[3];
 #endif
 }
 
diff --git a/util/net/http_transport_libcurl.cc b/util/net/http_transport_libcurl.cc
index d5c9177..230f487 100644
--- a/util/net/http_transport_libcurl.cc
+++ b/util/net/http_transport_libcurl.cc
@@ -237,6 +237,8 @@
 #elif defined(ARCH_CPU_BIG_ENDIAN)
     static constexpr char arch[] = "aarch64_be";
 #endif
+#elif defined(ARCH_CPU_LOONGARCH64)
+    static constexpr char arch[] = "loongarch64";
 #else
 #error Port
 #endif
